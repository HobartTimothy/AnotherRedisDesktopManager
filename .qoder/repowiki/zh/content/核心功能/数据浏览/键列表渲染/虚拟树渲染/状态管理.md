# 状态管理

<cite>
**本文档引用的文件**
- [KeyListVirtualTree.vue](file://src/components/KeyListVirtualTree.vue)
- [tree-store.js](file://node_modules/@qii404/vue-easy-tree/src/components/model/tree-store.js)
- [node.js](file://node_modules/@qii404/vue-easy-tree/src/components/model/node.js)
- [ve-tree.vue](file://node_modules/@qii404/vue-easy-tree/src/components/ve-tree.vue)
</cite>

## 目录
1. [简介](#简介)
2. [展开状态管理](#展开状态管理)
3. [多选状态管理](#多选状态管理)
4. [Shift多选操作机制](#shift多选操作机制)
5. [响应式高度调整](#响应式高度调整)
6. [结论](#结论)

## 简介
本文档全面分析虚拟树组件的状态管理机制，重点阐述展开状态、多选状态、Shift多选操作和响应式高度调整等核心功能的实现原理。通过深入分析代码结构和数据流，揭示组件如何高效管理大量节点的状态信息。

**Section sources**
- [KeyListVirtualTree.vue](file://src/components/KeyListVirtualTree.vue)

## 展开状态管理

### expandedKeys集合的实现
虚拟树组件使用`Set`数据结构来维护文件夹的展开状态，通过`expandedKeys`属性存储所有已展开节点的唯一标识。这种设计具有以下优势：

1. **高效查找**：`Set`提供O(1)时间复杂度的查找性能，确保在大量节点中快速判断某个节点是否已展开
2. **自动去重**：`Set`天然保证元素的唯一性，避免重复存储相同的键值
3. **内存效率**：相比数组，`Set`在存储大量唯一键值时更加内存友好

当用户展开一个文件夹节点时，系统通过`nodeExpand`方法将节点的键值添加到`expandedKeys`集合中：

```javascript
nodeExpand(data, node, component) {
  this.expandedKeys.add(data.key);
}
```

相应地，当用户折叠节点时，通过`nodeCollapse`方法从集合中移除对应的键值：

```javascript
nodeCollapse(data, node, component) {
  this.expandedKeys.delete(data.key);
}
```

### 数据更新时的状态保持
在`watch`监听器中，当`keyList`数据发生变化时，组件会保留原有的展开状态。通过将`expandedKeys`作为参数传递给`keysToTree`工具函数，确保在重新构建树结构时恢复之前的展开状态：

```javascript
const keyNodes = this.separator
  ? this.$util.keysToTree(newListCopy, this.separator, this.expandedKeys, this.treeNodesOverflow)
  : this.$util.keysToList(newListCopy);
```

**Section sources**
- [KeyListVirtualTree.vue](file://src/components/KeyListVirtualTree.vue#L145-L155)
- [KeyListVirtualTree.vue](file://src/components/KeyListVirtualTree.vue#L410-L412)

## 多选状态管理

### checkedKeys数组的作用
`checkedKeys`数组用于保存多选操作中的选中状态，确保在数据更新后能够准确恢复之前的选中项。该数组的管理流程如下：

1. **状态备份**：在数据更新前，通过`getCheckedKeys(true)`方法获取所有选中节点的键值并保存到`checkedKeys`数组中
2. **状态恢复**：在数据更新完成后，通过`setCheckedLeafKeys`方法将保存的键值重新应用到新的树结构中

```javascript
// 备份选中状态
this.checkedKeys = this.$refs.veTree.getCheckedKeys(true);

// 恢复选中状态
this.$refs.veTree.setCheckedLeafKeys(this.checkedKeys);
```

### $nextTick的必要性
在`watch`监听器中使用`$nextTick`确保DOM更新完成后再执行`setCheckedLeafKeys`操作，这是至关重要的设计决策：

1. **异步更新队列**：Vue的响应式系统将数据变更放入异步队列，在下一个事件循环中批量更新DOM
2. **避免状态丢失**：如果在DOM更新完成前尝试设置选中状态，目标节点可能尚未渲染，导致状态设置失败
3. **保证执行顺序**：`$nextTick`确保在新的树结构完全渲染后才恢复选中状态，保证用户体验的一致性

```javascript
this.$nextTick(() => {
  // sort outermost layer nodes
  this.$util.sortByTreeNodes(this.$refs.veTree.root.childNodes);
  // recheck checked nodes
  this.$refs.veTree.setCheckedLeafKeys(this.checkedKeys);
});
```

### setCheckedLeafKeys的实现原理
`setCheckedLeafKeys`方法通过`TreeStore`内部机制高效地恢复选中状态：

1. **直接设置节点状态**：遍历提供的键值数组，直接设置对应节点的`checked`属性为`true`，`indeterminate`属性为`false`
2. **递归更新父节点**：调用`_initCheckRecursive`方法从根节点开始递归更新所有父节点的半选状态

```javascript
setCheckedLeafKeys(keys) {
  for (let key of keys) {
    const node = this.nodesMap[key];
    node.checked = true;
    node.indeterminate = false;
  }
  this._initCheckRecursive(this.root);
}
```

**Section sources**
- [KeyListVirtualTree.vue](file://src/components/KeyListVirtualTree.vue#L407-L421)
- [tree-store.js](file://node_modules/@qii404/vue-easy-tree/src/components/model/tree-store.js#L312-L320)
- [ve-tree.vue](file://node_modules/@qii404/vue-easy-tree/src/components/ve-tree.vue#L308-L310)

## Shift多选操作机制

### 私有变量的协同工作
Shift多选操作依赖三个私有变量的协同工作，实现连续范围选择：

1. **lastKey**：存储上一次点击的节点键值，作为选择范围的起点
2. **lastY**：存储上一次点击的屏幕Y坐标，用于判断选择方向
3. **lastChecked**：存储上一次点击节点的选中状态，用于确定新选中节点的目标状态

```javascript
this.lastKey = node.key;
this.lastY = event.screenY;
this.lastChecked = node.checked;
```

### 选择范围计算
当用户按住Shift键并点击另一个节点时，系统根据以下逻辑计算选择范围：

1. **方向判断**：通过比较当前点击位置和上次点击位置的Y坐标，确定选择方向（向上或向下）
2. **边界确定**：根据选择方向确定范围的顶部和底部边界节点
3. **路径收集**：从底部向上遍历数据列表，收集位于两个边界节点之间的所有节点

```javascript
const direction = (event.screenY - this.lastY) <= 0 ? 'up' : 'down';
const topKey = direction == 'up' ? curKey : this.lastKey;
const bottomKey = direction == 'up' ? this.lastKey : curKey;
```

### 状态同步与更新
在收集到需要选中的节点后，系统执行以下操作：

1. **排除父节点**：创建`bottomNodeParents`集合，存储底部节点的所有父节点，避免在范围选择中重复选中父节点
2. **批量设置状态**：遍历收集的节点列表，调用`checkRecursive`函数递归设置每个节点及其子节点的选中状态
3. **更新父节点状态**：调用`_initCheckRecursive`方法重新计算所有父节点的半选状态，确保树结构的完整性

```javascript
for (const item of selectedNodes) {
  if (bottomNodeParents.has(item.key)) {
    continue;
  }
  checkRecursive(item, this.lastChecked);
}
// reinit folder node check status
this.$refs.veTree.store._initCheckRecursive(tree.root);
```

**Section sources**
- [KeyListVirtualTree.vue](file://src/components/KeyListVirtualTree.vue#L319-L388)
- [node.js](file://node_modules/@qii404/vue-easy-tree/src/components/model/node.js#L25-L46)

## 响应式高度调整

### vtreeHeight属性的动态调整
`vtreeHeight`响应式属性根据多选模式动态调整树形组件的高度，提供更好的用户体验：

1. **初始设置**：在组件创建时，将高度设置为原始值`vtreeHeightRaw`
2. **多选模式**：进入多选模式时，高度调整为`vtreeHeightMutiple`，为批量操作按钮预留空间
3. **恢复模式**：退出多选模式时，高度恢复为原始值

```javascript
created() {
  this.vtreeHeight = this.vtreeHeightRaw;
}

showMultiSelect() {
  this.multiOperating = true;
  this.$refs.treeWrapper.classList.add('show-checkbox');
  // adjust vtree height
  this.vtreeHeight = this.vtreeHeightMutiple;
}

hideMultiSelect() {
  this.multiOperating = false;
  // recover vtree height
  this.vtreeHeight = this.vtreeHeightRaw;
}
```

### 样式类的配合
高度调整与CSS样式类协同工作，实现平滑的视觉过渡：

1. **批量操作容器**：`.batch-operate`容器默认隐藏，当添加`show-checkbox`类时显示
2. **高度计算**：使用CSS的`calc()`函数动态计算高度，考虑视口高度和固定元素的高度
3. **视觉一致性**：通过统一的样式管理，确保在不同模式下组件的外观协调一致

```css
.key-list-vtree .batch-operate {
  display: none;
}
.key-list-vtree.show-checkbox .batch-operate {
  display: block;
}
```

**Section sources**
- [KeyListVirtualTree.vue](file://src/components/KeyListVirtualTree.vue#L180-L195)
- [KeyListVirtualTree.vue](file://src/components/KeyListVirtualTree.vue#L86-L88)
- [KeyListVirtualTree.vue](file://src/components/KeyListVirtualTree.vue#L436-L437)

## 结论
虚拟树组件的状态管理机制体现了精心设计的架构思想：

1. **数据结构选择**：使用`Set`管理展开状态，利用其高效查找和去重特性
2. **异步更新策略**：通过`$nextTick`确保DOM更新完成后再恢复状态，避免竞态条件
3. **批量操作优化**：Shift多选算法高效计算选择范围，提供流畅的用户体验
4. **响应式设计**：动态调整组件高度，适应不同操作模式的需求

这些机制共同确保了组件在处理大量数据时的性能和用户体验，展现了现代前端开发中状态管理的最佳实践。